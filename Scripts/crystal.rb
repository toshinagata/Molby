#
#  crystal.rb
#
#  Created by Toshi Nagata.
#  Copyright 2012 Toshi Nagata. All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation version 2 of the License.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

#  Definition for use in ORTEP
class AtomRef
  def to_adc
    sym = self.symop
    if sym == nil
      idx = self.index + 1
      symcode = 55501
    else
      idx = sym[4] + 1
      symcode = (sym[1] + 5) * 10000 + (sym[2] + 5) * 1000 + (sym[3] + 5) * 100 + sym[0] + 1
    end
    return idx, symcode
  end
end

#  Used in bond_angle_with_sigma
module Math
  def acos_safe(arg)
    if arg <= -1.0
      return PI
    elsif arg >= 1.0
      return 0.0
    else
      return acos(arg)
    end
  end
end

class Molecule

#  Export ortep to File fp
#  If attr is a hash, it represents options for drawing.
#  "atoms"=>[[group, type, color, rad], [group, type, color, rad], ...]
#    group is an IntGroup, representing a group of atoms.
#    type is an atom type: 0 = boundary, 1 = boundary + principal, 2 = 1 + axes, 3 = 2 + shades, 4 = fixed size
#    color is 0..7 (0,1=black, 2=red, 3=green, 4=blue, 5=cyan, 6=magenta, 7=yellow)
#    rad is the radius of the atom (in Angstrom) whose type is fixed size
#    If an atom appears in multiple entries, the later entry is valid.
#  "bonds"=>[[group1, group2, type, color], [group1, group2, type, color], ...]
#    group1 and group2 are IntGroups, reprensenting the atoms constituting the bonds.
#    type is a bond type: 0 to 4 for bonds with no shades to 4 shades.
#    color is 0..7 as in atoms.
#    If a bond appears in multiple entries, the later entry is valid.
def export_ortep(fp, attr = nil)

  #  Create atom list
  hidden = atom_group { |ap| !is_atom_visible(ap.index) }
  hydrogen = self.show_hydrogens
  expanded = self.show_expanded
  atomlist = atom_group { |ap|
    (ap.element != "H" || hydrogen) &&
    (ap.symop == nil || expanded) &&
    (!hidden.include?(ap.index))
  }

  #  Title
  fp.printf "%-78.78s\n", self.name + ": generated by Molby at " + Time.now.to_s

  #  Cell parameters
  cp = self.cell
  if cp == nil
    cp = [1, 1, 1, 90, 90, 90]
  end
  fp.printf "%9.3f%9.3f%9.3f%9.3f%9.3f%9.3f\n", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]
  
  #  Symmetry operations
  syms = self.symmetries
  if syms == nil || syms.length == 0
   fp.print "1             0  1  0  0              0  0  1  0              0  0  0  1\n"
  else
    syms.each_with_index { |s, i|
      a = s.to_a
      fp.printf "%s%14g%3g%3g%3g%15g%3g%3g%3g%15g%3g%3g%3g\n", (i == syms.length - 1 ? "1" : " "), a[9], a[0], a[1], a[2], a[10], a[3], a[4], a[5], a[11], a[6], a[7], a[8]
    }
  end

  #  Atoms (all symmetry unique atoms regardless they are visible or not)
  n = 0
  aattr = (attr ? attr["atoms"] : nil)
  each_atom { |ap|
    break if ap.symop != nil
    fp.printf " %4.4s%22s%9.4f%9.4f%9.4f%9d\n", ap.name, "", ap.fract_x, ap.fract_y, ap.fract_z, 0
	rad = -1.0
	if aattr
	  aattr.reverse_each { |at|
	    if at[0].include?(ap.index)
		  if at[1] == 4
		    rad = at[3].to_f
		    if rad == 0.0
		      rad = 0.1
		    end
		  end
		  break
		end
	  }
	end
    an = ap.aniso
    if an != nil && rad < 0.0
      fp.printf " %8.5f%9.6f%9.6f%9.6f%9.6f%9.6f%9d\n", an[0], an[1], an[2], an[3], an[4], an[5], 0
    else
	  type = 7
	  if rad < 0.0
        rad = ap.temp_factor
        rad = 1.2 if rad <= 0
	    type = 6
	  end
      fp.printf " %8.3f%9g%9g%9g%9g%9g%9d\n", rad, 0.0, 0.0, 0.0, 0.0, 0.0, type
    end
    n += 1
  }
  natoms_tep = n

  #  Special points to specify cartesian axes
  axis, angle = self.get_view_rotation
  tr = Transform.rotation(axis, -angle)
  org = self.get_view_center
  x = org + tr.column(0)
  y = org + tr.column(1)
  tr = self.cell_transform
  if tr
    tr = tr.inverse
  else
    tr = Transform.identity
  end
  org = tr * org
  x = tr * x
  y = tr * y
  fp.printf " CNTR                      %9.4f%9.4f%9.4f        0\n", org.x, org.y, org.z
  fp.printf " %8.3f%9g%9g%9g%9g%9g%9d\n", 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 6
  fp.printf " X                         %9.4f%9.4f%9.4f        0\n", x.x, x.y, x.z
  fp.printf " %8.3f%9g%9g%9g%9g%9g%9d\n", 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 6
  fp.printf " Y                         %9.4f%9.4f%9.4f        0\n", y.x, y.y, y.z
  fp.printf "1%8.3f%9g%9g%9g%9g%9g%9d\n", 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 6

  #  Initialize
  fp.print  "      201\n"

  #  Pen size
  fp.print  "      205        8\n"

  #  Paper size, margin, viewing distance
  fp.print  "      301      6.6      6.6        0      0.0\n"

  #  Sort atoms by symop and index
  acodes = Hash.new
  ig = IntGroup.new   #  Used for collecting contiguous atoms
  each_atom(atomlist) { |ap|
    idx, symcode = ap.to_adc
    acode = symcode * self.natoms + idx - 1
    acodes[acode] = ap.index
    ig.add(acode)
  }
  index2an = []       #  Index in Molecule to Index in ORTEP
  ig.each_with_index { |acode, i|
    index2an[acodes[acode]] = i + 1
  }
  i = 0
  adcs = []
  while (r = ig.range_at(i)) != nil
    s = r.first
    s = (s / self.natoms) + (s % self.natoms + 1) * 100000  #  Rebuild true ADC (atom index is in the upper digit)
    e = r.last
    e = (e / self.natoms) + (e % self.natoms + 1) * 100000
    if s < e
      adcs.push(s)
      adcs.push(-e)
    else
      adcs.push(s)
    end
    i += 1
  end
  k = 0

  #  Atom list
  adcs.each_with_index { |a, i|
    if k == 0
      fp.print "      401"
    end
    fp.printf "%9d", a
    k += 1
    if i == adcs.length - 1 || k == 6 || (k == 5 && i < adcs.length - 2 && adcs[i + 2] < 0)
      fp.print "\n"
      k = 0
    end
  }

  #  Axes
  fp.printf "      501%4d55501%4d55501%4d55501%4d55501%4d55501                 1\n", natoms_tep + 1, natoms_tep + 1, natoms_tep + 2, natoms_tep + 1, natoms_tep + 3
#  fp.print  "      502        1      0.0        2      0.0        3      0.0\n"
  
  #  Autoscale
  fp.print  "      604                               1.538\n"
  
  #  Explicit bonds
  bond_inst = Array.new(35) { [] }   #  Bonds for types 0 to 4 and colors 1 to 7
  battr = (attr ? attr["bonds"] : nil)
  bonds.each { |b|
    next if !atomlist.include?(b[0]) || !atomlist.include?(b[1])
	btype = bcol = nil
	if battr
	  battr.reverse_each { |at|
	    if (at[0].include?(b[0]) && at[1].include?(b[1])) || (at[0].include?(b[1]) && at[1].include?(b[0]))
		  btype = at[2] % 5
		  bcol = (at[3] != 0 ? at[3] - 1 : at[3]) % 7
		  break
		end
	  }
	end
	if btype == nil
	  bcol = 0
      an1 = atoms[b[0]].atomic_number
      an2 = atoms[b[1]].atomic_number
      if an1 == 1 || an2 == 1
        btype = 0
      elsif an1 <= 8 && an2 <= 8
        btype = 2
      else
        btype = 4
      end
	end
    bond_inst[btype * 7 + bcol].push(b[0], b[1])
  }

  #  Output bond specifications
  #  Avoid including too many ADCs in a single 811/821 instruction
  #  (Upper limit is 140. Here we divide at every 36 ADCs)
  output_bonds = lambda { |icode|
    bond_inst.each_with_index { |inst, ii|
      next if inst.length == 0
	  btype = ii / 7 + 1
	  if icode / 10 == 81   #  811 instructions
	    fp.printf "      204%9d\n", ii % 7 + 1   #  Pen color
	  end
      inst.each_with_index { |b, i|
        if i % 6 == 0
          fp.printf "  %d   %3s", (i >= inst.length - 6 || i % 36 == 30 ? 2 : 1), (i % 36 == 0 ? icode.to_s : "")
        end
        idx, scode = atoms[b].to_adc
        fp.printf "%9d", idx * 100000 + scode
        if i % 6 == 5 || i == inst.length - 1
          fp.print "\n"
          if i == inst.length - 1 || i % 36 == 35
            fp.printf "%21s%3d%12s%6.3f\n", "", btype, "", 0.05
          end
        end
      }
    }
  }

  fp.print "  0  1001     0.02\n"  #  Activate hidden line removal
  output_bonds.call(821)
  
  #  Atom types
  #  Atom type 0=714 (boundary), 1=712 (+principal), 2=716 (+axes), 3=711 (+shades)
  atom_inst = Array.new(28) { IntGroup.new }
  aattr = (attr ? attr["atoms"] : nil)
  atomlist.each { |i|
    atype = acol = nil
	if aattr
	  aattr.reverse_each { |at|
	    if at[0].include?(i)
		  atype = at[1] % 4
		  acol = (at[2] != 0 ? at[2] - 1 : at[2]) % 7
		  break
		end
	  }
	end
	if atype == nil
	  acol = 0
      an1 = atoms[i].atomic_number
      if an1 == 1
        atype = 0
      elsif an1 <= 6
        atype = 1
      else
        atype = 3
      end
	end
    idx, scode = atoms[i].to_adc
    atom_inst[atype * 7 + acol].add(idx)
  }
  (atom_inst.count - 1).downto(0) { |ii|
    inst = atom_inst[ii]
	next if inst.count == 0
	fp.printf "      204%9d\n", ii % 7 + 1   #  Pen color
    i = 0
	atype = [714, 712, 716, 711][ii / 7]
    while (r = inst.range_at(i)) != nil
      fp.printf "  1   %3d\n", atype
      fp.printf "%27s%9d%9d\n", "", r.first, r.last
      i += 1
    end
  }

  output_bonds.call(811)

  #  Close plot
  fp.print "      202\n"
  fp.print "       -1\n"
  
end

def savetep(filename)
  if natoms == 0
	raise MolbyError, "cannot save ORTEP input; the molecule is empty"
  end
  fp = open(filename, "wb")
  export_ortep(fp)
  fp.close
  return true
end

end

module Math
  def sqrt_safe(arg)
    arg <= 0.0 ? 0.0 : sqrt(arg)
  end
end

#  Best-fit planes
#  Ref. W. C. Hamilton, Acta Cryst. 1961, 14, 185-189
#       T. Ito, Acta Cryst 1981, A37, 621-624

#  An object to describe the best-fit plane
#  
#  Contains the plane coefficients and the constant (a, b, c, d for ax + by + cz + d = 0),
#  the error matrix, and the metric tensor.
#
class Molby::Plane
  attr_accessor :molecule, :group, :coeff, :const, :error_matrix, :metric_tensor
  def initialize(mol, group, coeff, const, err, met)
    @molecule = mol
    @group = group
    @coeff = coeff
    @const = const
    @error_matrix = err
    @metric_tensor = met
    self
  end
  def sigma
    [sqrt_safe(@error_matrix[0, 0]), sqrt_safe(@error_matrix[1, 1]), sqrt_safe(@error_matrix[2, 2]), sqrt_safe(@error_matrix[3, 3])]
  end
  def inspect
    s = sprintf("Molby::Plane[\n coeff, const = [[%f, %f, %f], %f],\n", @coeff.x, @coeff.y, @coeff.z, @const)
    s += sprintf(" sigma = [[%10.4e, %10.4e, %10.4e], %10.4e],\n", *self.sigma)
    (0..3).each { |i|
      s += (i == 0 ? " error_matrix = [" : "     ")
      (0..i).each { |j|
        s += sprintf("%12.6e%s", @error_matrix[j, i], (j == i ? (i == 3 ? "],\n" : ",\n") : ","))
      }
    }
    s += sprintf(" molecule = %s\n", @molecule.inspect)
    s += sprintf(" group = %s\n", @group.inspect)
    (0..3).each { |i|
      s += (i == 0 ? " metric_tensor = [" : "     ")
      (0..3).each { |j|
        s += sprintf("%12.6e%s", @metric_tensor[j, i], (j == 3 ? (i == 3 ? "]]\n" : ",\n") : ","))
      }
    }
    s
  end
  def distance(ap)
    if ap.is_a?(AtomRef)
      fr = ap.fract_r
      sig = ap.sigma
    else
      fr = Vector3D[*ap]
      sig = Vector3D[0, 0, 0]
    end
    d = fr.dot(@coeff) + @const
    sig1 = (@coeff.x * sig.x) ** 2 + (@coeff.y * sig.y) ** 2 + (@coeff.z * sig.z) ** 2
    sig2 = LAMatrix.multiply("t", fr, @error_matrix, fr)[0, 0]
    if ap.is_a?(AtomRef) && ap.molecule == @molecule && @group.include?(ap.index)
      #  The atom defines the plane
      sig0 = sig1 - sig2
      sig0 = 0.0 if sig0 < 0.0
    else
      sig0 = sig1 + sig2
    end  
    return d, sqrt_safe(sig0)
  end
  def dihedral(plane)
    e1 = @error_matrix.submatrix(0, 0, 3, 3)
    e2 = plane.error_matrix.submatrix(0, 0, 3, 3)
    m = @metric_tensor.submatrix(0, 0, 3, 3)
    c = plane.coeff
    cos_t = plane.coeff.dot(m * @coeff)
    if cos_t > 1.0
      cos_t = 1.0
    elsif cos_t < -1.0
      cos_t = -1.0
    end
    t = acos(cos_t)
    sig_t = (m * e1).trace + (m * e2).trace
    if sig_t < t * t
      w = 1.0 / sin(t)
      sig_t = w * w * (c.dot(LAMatrix.multiply(m, e1, m, c)) + @coeff.dot(LAMatrix.multiply(m, e2, m, @coeff)))
    end
    t *= 180.0 / PI
    sig_t = sqrt_safe(sig_t) * 180.0 / PI
    return t, sig_t
  end
end

class Molecule

#  Calculate best-fit plane for the given atoms
#  Return value: a Molby::Plane object

def plane(group)

  #  Number of atoms
  dim = group.length

  #  Positional parameters and standard deviations
  x = []
  sig = []
  sig_min = 1e10
  each_atom(group) { |ap|
    x.push(ap.fract_r)
    sig.push(ap.sigma)
    if (s = ap.sigma_x) > 0.0 && s < sig_min
      sig_min = s
    end
    if (s = ap.sigma_y) > 0.0 && s < sig_min
      sig_min = s
    end
    if (s = ap.sigma_z) > 0.0 && s < sig_min
      sig_min = s
    end
  }
  if sig_min == 1e10
    sig_min = 1e-12
  end
  sig.each { |s|
    s.x = sig_min if s.x < sig_min
    s.y = sig_min if s.y < sig_min
    s.z = sig_min if s.z < sig_min
  }

  #  The metric tensor of the reciprocal lattice
  #  g[j, i] = (ai*).dot(aj*), where ai* and aj* are the reciprocal axis vectors
  t = self.cell_transform
  if t.nil?
    t = Transform.identity
  end
  g2inv = LAMatrix[t]
  g2 = g2inv.inverse
  g2[3, 3] = 0.0
  g2inv[3, 3] = 0.0
  g = LAMatrix.multiply("t", g2, g2)

  #  The variance-covariance matrices of the atomic parameters
  #  mm[k][n] is a 3x3 matrix describing the correlation between the atoms k and n,
  #  and its components are defined as: sigma_k[i] * sigma_n[j] * corr[k, i, n, j],
  #  where corr(k, i, n, j) is the correlation coefficients between the atomic parameters
  #  k[i] and n[j].
  mm = Array.new(dim) { Array.new(dim) }
  zero = LAMatrix.zero(3, 3)
  dim.times { |k|
    dim.times { |n|
      mkn = LAMatrix.new(3, 3)
      if k == n
        3.times { |i|
          3.times { |j|
            if i == j
              mkn[j, i] = sig[k][i] * sig[n][j]
            else
              #  Inter-coordinate correlation should be implemented here
            end
          }
        }
      else
        #  Inter-atomic correlation should be implemented here
      end
      mm[k][n] = (mkn == zero ? zero : mkn)
    }
  }

  #  The variance-covariance matrix of the atom-plance distances
  #  m[j, i] = v.transpose * mm[i][j] * v, where v is the plane coefficient vector
  #  The inverse of m is the weight matrix
  m = LAMatrix.new(dim, dim)
  
  #  The matrix representation of the atomic coordinates
  #  y[j, i] = x[i][j] (for j = 0..2), -1 (for j = 3)
  #  y * LAMatrix[a, b, c, d] gives the atom-plane distances for each atom
  y = LAMatrix.new(4, dim)
  dim.times { |i|
    y[0, i] = x[i].x
    y[1, i] = x[i].y
    y[2, i] = x[i].z
    y[3, i] = 1.0
  }

  #  The coefficients to be determined
  n0 = LAMatrix[1, 1, 1, 0]
  v = LAMatrix[1, 1, 1]     #  The coefficient part

  iter = 0
  while iter < 20

    iter += 1

    #  Set zero to the "constant" part, and normalize the "coefficient" part
    n0[0, 3] = 0.0
    n0 = g2 * n0
    n0.multiply!(1.0 / n0.fnorm)
    n0 = g2inv * n0
    3.times { |i| v[0, i] = n0[0, i] }

    #  Build the variance-covariance matrix    
    dim.times { |i|
      dim.times { |j|
        m[j, i] = LAMatrix.multiply("t", v, mm[i][j], v)[0, 0]
      }
    }
    c = LAMatrix.multiply("t", y, "i", m, y)

    #  Invert c: only the inverse is used in the following, so c is inversed destructively
    cinv = c.inverse!
 
    if iter == 1

      #  Determine the tentative solution, which is given by the eigenvector of cinv * g
      #  for the largest eigenvalue
      evals, evecs = (cinv * g).eigenvalues
      4.times { |i| n0[0, i] = evecs[3, i] }

    else

      #  Convert the coefficient vector to the reciprocal space
      h = g * n0
      
      #  Determine multiplier
      #  In this implementation, the sign of delta-n is opposite from that used in
      #  the reference
      lam = 1.0 / (LAMatrix.multiply("t", h, cinv, h)[0, 0])
      
      #  Solve the linearized equation
      #  (Is the equation 21 in the reference really correct? Shouldn't it read
      #   B = 1 - lambda * C.inverse * H* ? )
      b = LAMatrix.multiply(lam, cinv, g)
      b.sub!(LAMatrix.identity(4))

      dn = b * n0
      n0 += dn

      break if dn[0, 0] ** 2 + dn[0, 1] ** 2 + dn[0, 2] ** 2 < 1e-9

    end
  end

  #  Error matrix = b * cinv * b.transpose
  em = LAMatrix.multiply(b, cinv, "t", b)
  coeff = Vector3D[n0[0, 0], n0[0, 1], n0[0, 2]]
  const = n0[0, 3]

  return Molby::Plane.new(self, group, coeff, const, em, g)

end

def cmd_plane
  plane_settings = @plane_settings || Hash.new
  mol = self
  h = Dialog.new("Best-Fit Planes: " + mol.name, "Close", nil) {
    refresh_proc = lambda { |it|
      n = it[:tag][/\d/].to_i
      g = plane_settings["group#{n}"]
      if g
        str = g.inspect.sub!("IntGroup[", "").sub!("]", "")
        set_value("group#{n}", str)
        if n == 1 || n == 2
          p = mol.plane(g) rescue p = nil
          plane_settings["plane#{n}"] = p
          if p
            coeff = p.coeff
            const = p.const
            sig = p.sigma
            aps = (n == 1 ? "" : "'")
            str = sprintf("a%s = %f(%f)\nb%s = %f(%f)\nc%s = %f(%f)\nd%s = %f(%f)",
                          aps, coeff.x, sig[0],
                          aps, coeff.y, sig[1],
                          aps, coeff.z, sig[2],
                          aps, const, sig[3])
            set_value("result#{n}", str)
          else
            set_value("result#{n}", "")
          end
          p1 = plane_settings["plane1"]
          p2 = plane_settings["plane2"]
          if p1 && p2
            t, sig = p1.dihedral(p2)
            str = sprintf("%f(%f)", t, sig)
            set_value("dihedral", str)
          else
            set_value("dihedral", "")
          end
        else
          p = plane_settings["plane1"]
          if p
            str = ""
            mol.each_atom(g) { |ap|
              d, sig = p.distance(ap)
              str += sprintf("%s  %f(%f)\n", ap.name, d, sig)
            }
            str.chomp!
          else
            str = ""
          end
          set_value("result#{n}", str)
        end
      else
        set_value("group#{n}", "")
        set_value("result#{n}", "")
      end
    }
    set_proc = lambda { |it|
      n = it[:tag][/\d/].to_i
      sel = mol.selection
      if sel.count > 0
        str = sel.inspect.sub!("IntGroup[", "").sub!("]", "")
        set_value("group#{n}", str)
        plane_settings["group#{n}"] = sel
      else
        plane_settings["group#{n}"] = nil
      end
      refresh_proc.call(it)
    }
    text_proc = lambda { |it|
      n = it[:tag][/\d/].to_i
      str = it[:value].gsub(/[^-.,0-9]/, "")  #  Remove unsane characters
      g = eval("IntGroup[#{str}]") rescue g = nil
      plane_settings["group#{n}"] = g
      refresh_proc.call(it)
    }
    layout(3,
      item(:text, :title=>"Plane 1 (ax + by + cz + d = 0)"),
      -1, -1,
      item(:text, :title=>"Atoms"),
      item(:textfield, :width=>240, :height=>32, :tag=>"group1", :action=>text_proc),
      item(:button, :title=>"Set Current Selection", :tag=>"button1", :action=>set_proc),
      item(:text, :title=>"Results"),
      item(:textview, :width=>240, :height=>68, :editable=>false, :tag=>"result1"),     
      item(:button, :title=>"Recalculate", :tag=>"refresh1", :action=>refresh_proc),
      item(:line),
      -1, -1,
      item(:text, :title=>"Plane 2 (a'x + b'y + c'z + d' = 0)"),
      -1, -1,
      item(:text, :title=>"Atoms"),
      item(:textfield, :width=>240, :height=>32, :tag=>"group2", :action=>text_proc),
      item(:button, :title=>"Set Current Selection", :tag=>"button2", :action=>set_proc),
      item(:text, :title=>"Results"),
      item(:textview, :width=>240, :height=>68, :editable=>false, :tag=>"result2"),
      item(:button, :title=>"Recalculate", :tag=>"refresh2", :action=>refresh_proc),
      item(:text, :title=>"Dihedral angle with Plane 1"), -1, -1,
      -1,
      item(:textfield, :width=>240, :height=>20, :tag=>"dihedral"), -1,
      item(:line),
      -1, -1,
      item(:text, :title=>"Distance from Plane 1"), -1, -1,
      item(:text, :title=>"Atoms"),
      item(:textfield, :width=>240, :height=>32, :tag=>"group3", :action=>text_proc),
      item(:button, :title=>"Set Current Selection", :tag=>"button3", :action=>set_proc),
      item(:text, :title=>"Results"),
      item(:textview, :width=>240, :height=>68, :editable=>false, :tag=>"result3"),
      item(:button, :title=>"Recalculate", :tag=>"refresh3", :action=>refresh_proc)
    )
    refresh_proc.call(item_with_tag("refresh1"))
    refresh_proc.call(item_with_tag("refresh2"))
    refresh_proc.call(item_with_tag("refresh3"))
	show
  }
  @plane_settings = plane_settings
end

#  Calculate bond length and angles with standard deviations
#  args can be a single IntGroup (calculate bonds and angles including those atoms)
#  or arrays of 2 or 3 integers (explicitly specifying bonds and angles)
def bond_angle_with_sigma(*args)

  if args.length >= 2 || (args.length == 1 && !args[0].is_a?(IntGroup))
    #  Bonds and angles are explicitly specified
    bonds = []
    angles = []
    args.each { |arg|
      if arg.length == 2 && arg[0].is_a?(Integer) && arg[1].is_a?(Integer)
        bonds.push(arg)
      elsif arg.length == 3 && arg[0].is_a?(Integer) && arg[1].is_a?(Integer) && arg[2].is_a?(Integer)
        angles.push(arg)
      else
        raise MolbyError, "Invalid argument #{arg.inspect}"
      end
    }
  else
    if args.length == 0
	  g = nil
	else
	  g = args[0]
	end
	bonds = self.bonds.select { |b|
	  (g == nil || (g.include?(b[0]) && g.include?(b[1]))) &&
	    (atoms[b[0]].symop == nil || atoms[b[1]].symop == nil)
	}
	angles = self.angles.select { |ang|
	  (g == nil || (g.include?(ang[0]) && g.include?(ang[1]) && g.include?(ang[2]))) &&
	    (atoms[ang[0]].symop == nil || atoms[ang[1]].symop == nil || atoms[ang[2]].symop == nil)
	}
  end

  #  A list of interatomic distance, its differential coefficients, and other
  #  useful quantities.
  #  The hash tag is a list [i, j] (i and j are the atom indices) or [i, j, k]
  #  (i, j, k are the atom indices, and r(ijk) is the distance between the atom i
  #  and the center point between the atoms j and k).
  #  The value is a list of following quantities:
  #    index 0: rij or r(ijk)
  #    index 1-9: d(rij)/d(xij), d(rij)/d(yij), d(rij)/d(zij),
  #      d(rij)/da, d(rij)/db, d(rij)/dc, d(rij)/d(alpha), d(rij)/d(beta), d(rij)/d(gamma)
  #    index 10: the list of the "base atom"
  #    index 11: the list of the transform matrices
  dlist = Hash.new

  #  A list of fractional coordinates and sigmas
  fract = []
  sigma = []
  each_atom { |ap|
    fract.push(ap.fract_r)
    sigma.push(ap.sigma)
  }

  #  A list of base atoms (for symmetry-related atoms) and transform matrices
  bases = []
  trans = []
  symcode = []
  trans_i = Transform.identity
  each_atom { |ap|
    sym = ap.symop
    bases.push(sym ? sym[4] : ap.index)
	if sym
	  tr = transform_for_symop(sym).transpose
      tr[3, 0] = tr[3, 1] = tr[3, 2] = 0.0
	else
	  tr = trans_i
	end
    trans.push(tr)
	symcode.push(sym ? sprintf("%d_%d%d%d", sym[0] + 1, sym[1] + 5, sym[2] + 5, sym[3] + 5) : ".")
  }

  #  Unit cell parameter
  cell = self.cell
  if cell.length == 6
    cell.push(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)  #  No sigma information
  end
  # $a, $b, $c, $alpha, $beta, $gamma, $sig_a, $sig_b, $sig_c, $sig_alpha, $sig_beta, $sig_gamma = self.cell
  cos_a = cos(cell[3] * PI / 180.0)
  cos_b = cos(cell[4] * PI / 180.0)
  cos_c = cos(cell[5] * PI / 180.0)
  abc = cell[0] * cell[1] * cos_c
  bca = cell[1] * cell[2] * cos_a
  cab = cell[2] * cell[0] * cos_b
  aa = cell[0] * cell[0]
  bb = cell[1] * cell[1]
  cc = cell[2] * cell[2]

  get_dlist = lambda { |_i, _j, _k|
    if _k != nil
      if _j > _k
        _j, _k = _k, _j
      end
      _p = dlist[[_i, _j, _k]]
      return _p if _p != nil
      _p = (dlist[[_i, _j, _k]] = [])
      _vij = fract[_i] - (fract[_j] + fract[_k]) * 0.5
      _p[10] = [bases[_i], bases[_j], bases[_k]]
      _p[11] = [trans[_i], trans[_j], trans[_k]]
    else
      if _i > _j
        _i, _j = _j, _i
      end
      _p = dlist[[_i, _j]]
	  return _p if _p != nil
      _p = (dlist[[_i, _j]] = [])
      _vij = fract[_i] - fract[_j]
      _p[10] = [bases[_i], bases[_j]]
      _p[11] = [trans[_i], trans[_j]]
    end
    _xij = _vij.x
    _yij = _vij.y
    _zij = _vij.z
    _dij = sqrt_safe(aa * _xij * _xij + bb * _yij * _yij + cc * _zij * _zij + 2 * bca * _yij * _zij + 2 * cab * _zij * _xij + 2 * abc * _xij * _yij)
    _p[0] = _dij
    _p[1] = (aa * _xij + abc * _yij + cab * _zij) / _dij
    _p[2] = (bb * _yij + bca * _zij + abc * _xij) / _dij
    _p[3] = (cc * _zij + cab * _xij + bca * _yij) / _dij
    _p[4] = (cell[0] * _xij * _xij + cell[2] * cos_b * _zij * _xij + cell[1] * cos_c * _xij * _yij) / _dij
    _p[5] = (cell[1] * _yij * _yij + cell[0] * cos_c * _xij * _yij + cell[2] * cos_a * _yij * _zij) / _dij
    _p[6] = (cell[2] * _zij * _zij + cell[1] * cos_a * _yij * _zij + cell[0] * cos_b * _zij * _xij) / _dij
    _p[7] = (-cell[1] * cell[2] * sin(cell[3] * PI / 180.0) * _yij * _zij) * (PI / 180.0) / _dij
    _p[8] = (-cell[2] * cell[0] * sin(cell[4] * PI / 180.0) * _zij * _xij) * (PI / 180.0) / _dij
    _p[9] = (-cell[0] * cell[1] * sin(cell[5] * PI / 180.0) * _xij * _yij) * (PI / 180.0) / _dij
    return _p
  }

  diff_by_rn = lambda { |_dl, _n, _ijk|
    #  dl = dlist(i, j)
    #  return value: Vector3D[ d(rij)/d(xn), d(rij)/d(yn), d(rij)/d(zn) ]
    #  If ijk is true, then dl is dlist(i, j, k)
    _dv = Vector3D[_dl[1], _dl[2], _dl[3]]
    _c = Vector3D[0, 0, 0]
    if _dl[10][0] == _n
      _c += _dl[11][0] * _dv
    end
    if _ijk
      if _dl[10][1] == _n
        _c -= _dl[11][1] * _dv * 0.5
      end
      if _dl[10][2] == _n
        _c -= _dl[11][2] * _dv * 0.5
      end
    else
      if _dl[10][1] == _n
        _c -= _dl[11][1] * _dv
      end
    end
	return _c
  }

  notate_with_sigma = lambda { |_val, _sig|
    if _sig == 0.0
      return sprintf "%.4f", _val
    end
    _lg = log(_sig.abs / 1.95) / log(10.0)
    _n = -(_lg.floor)
    _val2 = (_val * (10 ** _n) + 0.5).floor * (0.1 ** _n)
    return sprintf "%.#{_n}f(%d)", _val2, (_sig * (10 ** _n) + 0.5).floor
  }

  results = []

  c = Vector3D[0, 0, 0]
  bonds.each { |b|
    i = b[0]
    j = b[1]
    if i > j
      i, j = j, i
    end
    p = get_dlist.call(i, j, nil)
    sig = 0.0
    p[10].uniq.each { |k|
      s = sigma[k]
      next unless s
      c = diff_by_rn.call(p, k, false)
      #  Test
      if nil
        apk = atoms[k]
        r = apk.fract_r
        d0 = calc_bond(i, j)
        apk.fract_r = r + Vector3D[0.00001, 0, 0]
        amend_by_symmetry(p[10])
        d1 = calc_bond(i, j)
        apk.fract_r = r + Vector3D[0, 0.00001, 0]
        amend_by_symmetry(p[10])
        d2 = calc_bond(i, j)
        apk.fract_r = r + Vector3D[0, 0, 0.00001]
        amend_by_symmetry(p[10])
        d3 = calc_bond(i, j)
        apk.fract_r = r
        amend_by_symmetry(p[10])
        printf " dr/dv[%d] cal %10.5g %10.5g %10.5g\n", k, c[0], c[1], c[2]
        printf " dr/dv[%d] est %10.5g %10.5g %10.5g\n", k, (d1 - d0) / 0.00001, (d2 - d0) / 0.00001, (d3 - d0) / 0.00001
      end
      sig += c[0] * c[0] * s[0] * s[0] + c[1] * c[1] * s[1] * s[1] + c[2] * c[2] * s[2] * s[2]
    }
    6.times { |n|
      sig += (p[4 + n] * cell[6 + n]) ** 2
    }
    sig = sqrt_safe(sig)
    results.push([[i, j], notate_with_sigma.call(p[0], sig), symcode[i], symcode[j], nil])
  }

  angles.each { |ang|
    i = ang[0]
    j = ang[1]
    k = ang[2]
    p0 = get_dlist.call(i, j, nil)
    p1 = get_dlist.call(j, k, nil)
    p2 = get_dlist.call(i, k, nil)
    p3 = get_dlist.call(j, i, k)
    t123 = acos_safe((p0[0] ** 2 + p1[0] ** 2 - p2[0] ** 2) / (2 * p0[0] * p1[0]))
    t124 = acos_safe((p0[0] ** 2 + p3[0] ** 2 - p2[0] ** 2 * 0.25) / (2 * p0[0] * p3[0]))
    t324 = acos_safe((p1[0] ** 2 + p3[0] ** 2 - p2[0] ** 2 * 0.25) / (2 * p1[0] * p3[0]))
    dtdr12 = -(p0[0] ** 2 - p3[0] ** 2 + p2[0] ** 2 * 0.25) / (2 * p3[0] * (p0[0] ** 2) * sin(t124))
    dtdr23 = -(p1[0] ** 2 - p3[0] ** 2 + p2[0] ** 2 * 0.25) / (2 * p3[0] * (p1[0] ** 2) * sin(t324))
    dtdr13 = p2[0] / (sin(t124) * 4 * p0[0] * p3[0]) + p2[0] / (sin(t324) * 4 * p1[0] * p3[0])
    dtdr24 = -(p3[0] ** 2 - p0[0] ** 2 + p2[0] ** 2 * 0.25) / (2 * (p3[0] ** 2) * p0[0] * sin(t124)) - (p3[0] ** 2 - p1[0] ** 2 + p2[0] ** 2 * 0.25) / (2 * (p3[0] ** 2) * p1[0] * sin(t324))
    pp = (p0[10] + p1[10] + p2[10] + p3[10]).uniq
    sig = 0.0
    pp.each { |n|
      s = sigma[n]
      next unless s
      c = Vector3D[0, 0, 0]
      c += diff_by_rn.call(p0, n, false) * (dtdr12 * 180.0 / PI)
      c += diff_by_rn.call(p1, n, false) * (dtdr23 * 180.0 / PI)
      c += diff_by_rn.call(p2, n, false) * (dtdr13 * 180.0 / PI)
      c += diff_by_rn.call(p3, n, true) * (dtdr24 * 180.0 / PI)
      sig += c[0] * c[0] * s[0] * s[0] + c[1] * c[1] * s[1] * s[1] + c[2] * c[2] * s[2] * s[2]
    }
    dd = dtdr12 * p0[4] + dtdr23 * p1[4] + dtdr13 * p2[4] + dtdr24 * p3[4]
    sig += dd * dd * cell[6] * cell[6]
    dd = dtdr12 * p0[5] + dtdr23 * p1[5] + dtdr13 * p2[5] + dtdr24 * p3[5]
    sig += dd * dd * cell[7] * cell[7]
    dd = dtdr12 * p0[6] + dtdr23 * p1[6] + dtdr13 * p2[6] + dtdr24 * p3[6]
    sig += dd * dd * cell[8] * cell[8]
    dd = dtdr12 * p0[7] + dtdr23 * p1[7] + dtdr13 * p2[7] + dtdr24 * p3[7]
    sig += dd * dd * cell[9] * cell[9]
    dd = dtdr12 * p0[8] + dtdr23 * p1[8] + dtdr13 * p2[8] + dtdr24 * p3[8]
    sig += dd * dd * cell[10] * cell[10]
    dd = dtdr12 * p0[9] + dtdr23 * p1[9] + dtdr13 * p2[9] + dtdr24 * p3[9]
    sig += dd * dd * cell[11] * cell[11]
    sig = sqrt_safe(sig)
    results.push([[i, j, k], notate_with_sigma.call(t123*180/PI, sig), symcode[i], symcode[j], symcode[k]])
  }
  results
end

def cmd_bond_angle_with_sigma
  mol = self
  Dialog.new("Bond & Angle with Sigma:" + self.name, nil, nil) {
    values = []
	clicked = []
	sel = mol.selection
	on_get_value = lambda { |it, row, col| values[row][col + 2] }
	atom_name = lambda { |ap|
	  (ap.molecule.nresidues >= 2 ? "#{ap.res_seq}:" : "") + ap.name
	}
    layout(1,
	  item(:table, :width=>480, :height=>300, :tag=>"table",
	    :columns=>[["Bond/Angle", 140], "value(sigma)", "symop1", "symop2", "symop3"],
		:on_count=> lambda { |it| values.count },
		:on_get_value=> on_get_value),
	  layout(2,
	    item(:view, :width=>480, :height=>1), -1,
	    item(:button, :title=>"Export to Clipboard", :tag=>"dump",
		  :action=>lambda { |item|
		    s = ""; values.each { |val| s += val[2..-1].join("  ") + "\n" }; export_to_clipboard(s)
		  },
		  :enabled=>false),
		[item(:button, :title=>"Close", :action=>lambda { |item| hide }), {:align=>:right}])
	)
	on_document_modified = lambda { |*d|
	  # puts "on_document_modified called: newsel = #{mol.selection}, sel = #{sel}"
	  newsel = mol.selection
	  val1 = val2 = nil
	  if sel != newsel
	    n1 = newsel.count
		if n1 == 0
		  #  Clear selection
		  clicked.clear
		elsif n1 == 1 && !clicked.include?(newsel[0])
		  #  New atom
		  clicked.clear
		  clicked[0] = newsel[0]
		  val1 = [[clicked[0]], "---", "", "", ""]
		elsif n1 == 2 && clicked.length == 1
		  #  New bond
		  if newsel[0] == clicked[0]
		    clicked[1] = newsel[1]
		  elsif newsel[1] == clicked[0]
		    clicked[1] = newsel[0]
		  else
		    clicked[0] = newsel[0]
			clicked[1] = newsel[1]
		  end
		  val1 = mol.bond_angle_with_sigma(clicked)[0]
		elsif n1 == 3 && clicked.length == 2 && newsel.include?(clicked[0]) && newsel.include?(clicked[1])
		  #  New angle
		  clicked[2] = (newsel - clicked)[0]
		  val1 = mol.bond_angle_with_sigma(clicked[1..2])[0]
		  val2 = mol.bond_angle_with_sigma(clicked)[0]
		else
		  return
		end
		[val1, val2].each { |val|
		  next unless val
		  label = ""
		  n = val[0].length
		  n.times { |i|
		    label += atom_name.call(mol.atoms[val[0][i]])
			if val[0][i + 1]
			  label += (mol.bond_exist?(val[0][i], val[0][i + 1]) ? "-" : "...")
			end
		  }
		  val[1, 0] = label
		  val.unshift(n)  #  val = [count, indices, label, value(sigma), symop1, symop2, symop3]
		}
	    if values[-1] && values[-1][0] == 1
		  values.pop
		end
		values.push(val1) if val1
		values.push(val2) if val2
		sel = newsel
		item_with_tag("table")[:refresh] = true
		item_with_tag("dump")[:enabled] = (values.length > 0)
	  end
	}
    listen(mol, "documentModified", on_document_modified)
	listen(mol, "documentWillClose", lambda { |*d| hide } )
	on_document_modified.call
	show
  }
end

def find_expanded_atom(base, symop)
  return base unless symop
  symopb = symop + [base]
  self.each_atom { |ap|
    if ap.symop == symopb
      return ap.index
    end
  }
  nil
end

def complete_by_symmetry
  if self.box == nil
    raise "Unit cell should be given"
  end
  verbose = false
  avec, bvec, cvec = self.box
  syms = []
  self.nsymmetries.times { |n|
    syms.push(transform_for_symop([n, 0, 0, 0], true))
  }
  frags = []
  self.each_fragment { |f|
    frags.push(f)
  }
  close_pairs = []
  self.each_atom { |ap|
    #  Find if ap is contained in expansion
	next if ap.symop != nil  #  Already expanded
    rad = Parameter.builtin.elements[ap.atomic_number].radius
    syms.each_with_index { |sym, sym_idx|
      27.times { |n|
        dx = n % 3 - 1
        dy = (n / 3) % 3 - 1
        dz = (n / 9) % 3 - 1
        next if dx == 0 && dy == 0 && dz == 0 && sym_idx == 0
        symop = [sym_idx, dx, dy, dz]
		next if self.find_expanded_atom(ap.index, symop)
        r = sym * ap.r + avec * dx + bvec * dy + cvec * dz
        close_atoms = self.find_close_atoms(r, 1.2, rad)
        if close_atoms.length > 0
          #  ap * [sym, dx, dy, dz] is included in the expansion
          close_atoms.each { |ca|
            next if ca > ap.index
            i1 = frags.index { |f| f.include?(ca) }
            i2 = frags.index { |f| f.include?(ap.index) }
            pp = close_pairs.find { |p1| p1[0] == i1 && p1[1] == i2 && p1[2] == symop }
			if pp == nil
			  pp = [i1, i2, symop, [], [], [], []]
			  close_pairs.push(pp)
		    end
            if (r - atoms[ca].r).length2 > 0.0001
			  #  Normal case (bond between ca and ap)
			  pp[3].push(ca)
			  pp[4].push(ap.index)
			else
              #  Special position
              pp[5].push(ca)
              pp[6].push(ap.index)
            end
          }
        end
      }
    }
  }
  puts "close_pairs = #{close_pairs}" if verbose
  expand_pairs = lambda { |i1, symop, depth|
    #  Find expanded fragment that is close to fragment [i1, symop]
    next [] if depth > 16
    retval = []
    close_pairs.each { |pp|
      next if i1 != nil && pp[0] != i1
	  next if pp[3].count == 0   #  No real expansion
      #  Multiply two symops
      if symop
        symop2 = symop_for_transform(transform_for_symop(pp[2]) * transform_for_symop(symop))
        puts "multiply two symops: #{pp[2].inspect} * #{symop.inspect} -> #{symop2.inspect}" if verbose
      else
        symop2 = pp[2]
      end
      if symop2[0] == 0
        #  Translation only
        if symop2[1] == 0 && symop2[2] == 0 && symop2[3] == 0
		  #  No expansion, but pp[3] and pp[4] are still needed to make bonds
		  symop2 = nil
	    end
		#  Expand the atoms only at the marginal
	    retval.push([nil, symop, symop2, pp[3], pp[4], pp[5], pp[6]])
      else
        #  Expand fragment
        retval.push([pp[1], symop, symop2, pp[3], pp[4], pp[5], pp[6]])
        retval.concat(expand_pairs.call(pp[1], symop2, depth + 1))
      end
    }
    next retval
  }
  ex_pairs = expand_pairs.call(nil, nil, 0)
  puts "ex_pairs = #{ex_pairs}" if verbose

  #  Expand fragments
  duplicates = []
  ex_pairs.each { |ex|
    #  ex[0]: fragment to expand, ex[1], ex[2]: symop,
    #  ex[3], ex[4]: atoms to make bonds, ex[5], ex[6]: duplicate atoms
    n1 = self.natoms
    if ex[0] == nil
      f = IntGroup[ex[4]]
    else
      f = frags[ex[0]]
    end
	if ex[2] != nil
      self.expand_by_symmetry(f, ex[2][0], ex[2][1], ex[2][2], ex[2][3], true)
      puts "expand(#{f}, #{ex[2]}) -> atoms[#{n1}..#{self.natoms - n1}]" if verbose
	end
    ex[3].each_with_index { |x, i|
      x1 = self.find_expanded_atom(x, ex[1])
	  if ex[2] != nil
        x2 = f.index(ex[4][i]) + n1  #  New index of the expanded atom
	  else
	    x2 = ex[4][i]   #  Base atom
	  end
      create_bond(x1, x2)
      puts "create_bond(#{x1}, #{x2})" if verbose
    }
    #  Register duplicate atoms
	if ex[2] != nil
      ex[5].each_with_index { |x, i|
        x1 = self.find_expanded_atom(x, ex[1])
        x2 = f.index(ex[6][i]) + n1
        duplicates.each { |d|
          if d.include?(x1)
            d.push(x2)
            x2 = nil
            break
          end
        }
        if x2
          duplicates.push([x1, x2])
        end
      }
    end
  }
  puts "duplicates = #{duplicates}" if verbose
  
  #  Remove duplicate atoms
  rem = []
  duplicates.each { |d|
    d.each_with_index { |dn, i|
      next if i == 0
      #  Remake bonds
      self.atoms[dn].connects.each { |nn|
        create_bond(d[0], nn)
        puts "create_bond(#{d[0]}, #{nn})" if verbose
      }
      rem.push(dn)
    }
  }
  remove(rem)
  puts "remove(#{rem})" if verbose
  
end

def create_packing_diagram
  if self.box == nil
    error_message_box "Unit cell is not defined."
	return
  end
  expansion_box = (@expansion_box ||= [0.0, 1.0, 0.0, 1.0, 0.0, 1.0])
  h = Dialog.run("Create Packing Diagram") {
    layout(4,
	  item(:text, :title=>"Specify the expansion limits for each axis:"),
	  -1, -1, -1,
	  item(:text, :title=>"x"),
	  item(:textfield, :width=>80, :tag=>"xmin", :value=>sprintf("%.1f", expansion_box[0].to_f)),
	  item(:text, :title=>"..."),
	  item(:textfield, :width=>80, :tag=>"xmax", :value=>sprintf("%.1f", expansion_box[1].to_f)),
	  item(:text, :title=>"y"),
	  item(:textfield, :width=>80, :tag=>"ymin", :value=>sprintf("%.1f", expansion_box[2].to_f)),
	  item(:text, :title=>"..."),
	  item(:textfield, :width=>80, :tag=>"ymax", :value=>sprintf("%.1f", expansion_box[3].to_f)),
	  item(:text, :title=>"z"),
	  item(:textfield, :width=>80, :tag=>"zmin", :value=>sprintf("%.1f", expansion_box[4].to_f)),
	  item(:text, :title=>"..."),
	  item(:textfield, :width=>80, :tag=>"zmax", :value=>sprintf("%.1f", expansion_box[5].to_f)))
  }
  if h[:status] == 0
    @expansion_box[0] = h["xmin"].to_f
    @expansion_box[1] = h["xmax"].to_f
    @expansion_box[2] = h["ymin"].to_f
    @expansion_box[3] = h["ymax"].to_f
    @expansion_box[4] = h["zmin"].to_f
    @expansion_box[5] = h["zmax"].to_f
  else
    return
  end
  
  #  Enumerate all atoms within the expansion box
  syms = self.symmetries
  h = Hash.new
  xmin = @expansion_box[0]
  xmax = @expansion_box[1]
  ymin = @expansion_box[2]
  ymax = @expansion_box[3]
  zmin = @expansion_box[4]
  zmax = @expansion_box[5]
  xmin_d = xmin.floor
  xmax_d = xmax.floor - 1
  ymin_d = ymin.floor
  ymax_d = ymax.floor - 1
  zmin_d = zmin.floor
  zmax_d = zmax.floor - 1
  syms.each_with_index { |sym, i|
    each_atom { |ap|
      fr = sym * ap.fract_r
	  dx = fr.x.floor
	  dy = fr.y.floor
	  dz = fr.z.floor
	  fr.x -= dx
	  fr.y -= dy
	  fr.z -= dz
	  symopi = i * 1000000 + (50 - dx) * 10000 + (50 - dy) * 100 + 50 - dz
	  (h[symopi] ||= []).push(ap.index)
	  xmin_d.upto(xmax_d) { |xd|
	    next if fr.x + xd < xmin || fr.x + xd > xmax
	    ymin_d.upto(ymax_d) { |yd|
	      next if fr.y + yd < ymin || fr.y + yd > ymax
		  zmin_d.upto(zmax_d) { |zd|
		    next if fr.z + zd < zmin || fr.z + zd > zmax
			next if xd == 0 && yd == 0 && zd == 0
		    symopid = symopi + xd * 10000 + yd * 100 + zd
			(h[symopid] ||= []).push(ap.index)
		  }
		}
	  }
	}
  }
  h.keys.sort.each { |key|
    sym = key / 1000000
	dx = key % 1000000 / 10000 - 50
	dy = key % 10000 / 100 - 50
	dz = key % 100 - 50
	next if sym == 0 && dx == 0 && dy == 0 && dz == 0
#	puts "[#{sym},#{dx},#{dy},#{dz}]: #{h[key].inspect}"
	expand_by_symmetry(IntGroup[h[key]], sym, dx, dy, dz)
  }
end

def cmd_show_ortep
  mol = self
  tmp = create_temp_dir("ortep", mol.name)
  tepexe = "#{ResourcePath}/ortep3/ortep3"
  if $platform == "win"
    tepexe += ".exe"
  end
  tepdata = []
  tepbounds = [0, 0, 400, 400]
  descs = {
	"Atoms"=>[
	  ["all", "Shaded", "black", ""],
	  ["Li-Ar", "Principals", "black", ""],
	  ["C", "Boundary", "black", ""],
	  ["H", "Fixed", "black", "0.1"]
	],
	"Bonds"=>[
	  ["all", "all", "4 Shades", "black"],
	  ["Li-Ar", "Li-Ar", "3 Shades", "black"],
	  ["C", "Li-Ar", "2 Shades", "black"],
	  ["H", "all", "Open", "black"]
	]
  }
  Dialog.new("Show ORTEP:" + mol.name, nil, nil, :resizable=>true, :has_close_box=>true) {
    tepview = nil  #  Forward declaration
	tab = "Atoms"
	columns = {
	  "Atoms"=>[["atom list", 65], ["type", 80], ["color", 40], ["radius", 50]],
	  "Bonds"=>[["list1", 65], ["list2", 65], ["type", 80], ["color", 40]]
	}
	atom_types = ["Boundary", "Principals", "Axes", "Shaded", "Fixed"]
	bond_types = ["Open", "1 Shade", "2 Shades", "3 Shades", "4 Shades"]
	colors = ["black", "red", "green", "blue", "cyan", "magenta", "yellow"]
	#  ORTEP attributes
	get_ortep_attr = lambda {
	  attr = Hash.new
	  make_atom_list = lambda { |s, ln|
	    ss = s.scan(/[-.0-9A-Za-z]+/)
		# puts ss.inspect
		ss.inject(IntGroup[]) { |r, it|
		  if it == "all"
		    r.add(mol.all)
			next r
		  elsif it =~ /-|(\.\.)/
		    s0 = Regexp.last_match.pre_match
			s1 = Regexp.last_match.post_match
		  else
		    s0 = s1 = it
		  end
		  if s0 =~ /^[0-9]+$/
		    #  Atomic numbers
			s0 = s0.to_i
			if s1 !~ /^[0-9]+$/ || (s1 = s1.to_i) < s0
			  raise "Bad atom list specification: #{s} in line #{ln}"
			end
			r.add(s0..s1)
		  else
		    #  Atomic symbols
			s0 = Parameter.builtin.elements.find_index { |p| p.name == s0.capitalize }
			s1 = Parameter.builtin.elements.find_index { |p| p.name == s1.capitalize }
			if s0 == nil || s1 == nil
			  raise "Bad element symbol specification: #{s} in line #{ln}"
			end
			(s0..s1).each { |an|
			  r.add(mol.atom_group { |ap| ap.atomic_number == an } )
			}
		  end
		  r
		}
      }
	  #  Atoms
	  at = []
	  descs["Atoms"].each_with_index { |d, idx|
		list = make_atom_list.call(d[0], idx)
		type = atom_types.find_index { |it| it == d[1] } || 0
		col = (colors.find_index { |it| it == d[2] } || 0) + 1
		rad = d[3]
		at.push([list, type, col, rad])
	  }
	  attr["atoms"] = at
	  #  Bonds
	  bd = []
	  descs["Bonds"].each_with_index { |d, idx|
		list1 = make_atom_list.call(d[0], idx)
		list2 = make_atom_list.call(d[1], idx)
		type = bond_types.find_index { |it| it == d[2] } || 0
		col = (colors.find_index { |it| it == d[3] } || 0) + 1
		bd.push([list1, list2, type, col])
	  }
	  attr["bonds"] = bd
	  attr
	}
    on_update_ortep = lambda { |it|
	  #  ORTEP attributes
	  attr = get_ortep_attr.call
	  #  Create ORTEP input in the temporary directory
	  open(tmp + "/TEP.IN", "w") { |fp| mol.export_ortep(fp, attr) }
	  #  Run ORTEP
	  cwd = Dir.pwd
	  Dir.chdir(tmp)
	  if FileTest.exist?("TEP001.PRN")
	    File.unlink("TEP001.PRN")
	  end
	  pid = call_subprocess(tepexe, "Running ORTEP", nil, "NUL", "NUL")
	  if FileTest.exist?("TEP001.PRN")
	    File.rename("TEP001.PRN", "TEP001.ps")
	  end
	  Dir.chdir(cwd)
	  if pid != 0
	    msg = "ORTEP execution in #{tmp} failed with status #{pid}."
	    message_box(msg, "ORTEP Failed", :ok, :warning)
	  else
	    open(tmp + "/TEP001.ps", "r") { |fp|
		  tepdata.clear
		  tepbounds = [100000, 100000, -100000, -100000]
		  fp.each_line { |ln|
		    ln.chomp!
		    x, y, c = ln.split
			if ln =~ /setrgbcolor/
			  tepdata.push(["color", x.to_f, y.to_f, c.to_f])
			  next
			elsif ln =~ /setgray/
			  x = x.to_f
			  tepdata.push(["color", x, x, x])
			  next
			end
			x = x.to_i
			y = y.to_i
			if c == "m"
			  tepdata.push([x, y])
			elsif c == "l"
			  tepdata[-1].push(x, y)
			else
			  next
			end
			tepbounds[0] = x if x < tepbounds[0]
			tepbounds[1] = y if y < tepbounds[1]
			tepbounds[2] = x if x > tepbounds[2]
			tepbounds[3] = y if y > tepbounds[3]
		  }
		  #  [x, y, width, height]
		  tepbounds[2] -= tepbounds[0]
		  tepbounds[3] -= tepbounds[1]
		}
		tepview.refresh_rect(tepview[:frame])
	  end
	}
	on_draw_ortep = lambda { |it|
	  clear
	  frame = it[:frame]
	  brush(:color=>[1, 1, 1, 1])
	  pen(:color=>[1, 1, 1, 1])
	  draw_rectangle(frame)
	  pen(:color=>[0, 0, 0, 1])
	  rx = (frame[2] - 10.0) / tepbounds[2]
	  ry = (frame[3] - 10.0) / tepbounds[3]
	  rx = ry if rx > ry
	  dx = (frame[2] - tepbounds[2] * rx) * 0.5
	  dy = (frame[3] + tepbounds[3] * rx) * 0.5
	  tepdata.each { |d|
	    if d[0] == "color"
		  pen(:color=>[d[1], d[2], d[3], 1])
		  next
		end
	    x0 = (dx + (d[0] - tepbounds[0]) * rx).to_i
		y0 = (dy - (d[1] - tepbounds[1]) * rx).to_i
		(d.length / 2 - 1).times { |i|
		  x1 = (dx + (d[i * 2 + 2] - tepbounds[0]) * rx).to_i
		  y1 = (dy - (d[i * 2 + 3] - tepbounds[1]) * rx).to_i
		  draw_line(x0, y0, x1, y1)
		  x0 = x1
		  y0 = y1
		}
	  }
	}
	on_export_eps = lambda { |fname|
	  frame = item_with_tag("ortep")[:frame].dup
	  dx = dy = 5
	  rx = (frame[2] - dx * 2) / tepbounds[2]
	  ry = (frame[3] - dy * 2) / tepbounds[3]
	  rx = ry if rx > ry
	  frame[2] = (rx * tepbounds[2] + dx * 2).to_i
	  frame[3] = (rx * tepbounds[3] + dy * 2).to_i
	  #  Assumes A4 paper and center the bounding box
	  frame[0] = (595 - frame[2]) / 2
	  frame[1] = (842 - frame[3]) / 2
	  xmax = frame[0] + frame[2]
	  ymax = frame[1] + frame[3]
	  open(fname, "w") { |fp|
	    fp.print "%!PS-Adobe-3.0 EPSF-3.0
%%Creator: Molby
%%BoundingBox: #{frame[0]} #{frame[1]} #{xmax} #{ymax}
%%Pages: 1
%%Orientation: Landscape
%%BeginProlog
/m {moveto} def
/l {lineto} def
%%EndProlog
%%Page: 1 1
%%BeginPageSetup
0 setgray 1 setlinecap 1 setlinewidth
%%EndPageSetup
"
	    tepdata.each { |d|
	      if d[0] == "color"
		    fp.printf "%.3f %.3f %.3f setrgbcolor\n", d[1], d[2], d[3]
		    next
		  end
	      x0 = frame[0] + dx + (d[0] - tepbounds[0]) * rx
		  y0 = frame[1] + dy + (d[1] - tepbounds[1]) * rx
		  fp.printf "%.2f %.2f m\n", x0, y0
		  (d.length / 2 - 1).times { |i|
		    x1 = frame[0] + dx + (d[i * 2 + 2] - tepbounds[0]) * rx
		    y1 = frame[1] + dy + (d[i * 2 + 3] - tepbounds[1]) * rx
		    fp.printf "%.2f %.2f l\n", x1, y1
		    x0 = x1
		    y0 = y1
		  }
		  fp.print "stroke\n"
	    }
        fp.print "showpage\n%%Trailer\n%%EOF\n"
	  }
	}
	on_export_bitmap = lambda { |fname|
	  frame = item_with_tag("ortep")[:frame].dup
	  dx = dy = 5
	  scale = 5.0
	  rx = (frame[2] - dx * 2) * scale / tepbounds[2]
	  ry = (frame[3] - dy * 2) * scale / tepbounds[3]
	  rx = ry if rx > ry
	  frame[2] = (rx * tepbounds[2] + dx * 2).to_i
	  frame[3] = (rx * tepbounds[3] + dy * 2).to_i
      bmp = Bitmap.new(frame[2], frame[3], 32)
	  bmp.focus_exec {
	    clear
	    pen(:color=>[0, 0, 0, 1], :width=>scale)
	    tepdata.each { |d|
	      if d[0] == "color"
		    pen(:color=>[d[1], d[2], d[3], 1])
		    next
		  end
	      x0 = (dx + (d[0] - tepbounds[0]) * rx).to_i
		  y0 = (dy + (tepbounds[3] - d[1] + tepbounds[1]) * rx).to_i
		  (d.length / 2 - 1).times { |i|
		    x1 = (dx + (d[i * 2 + 2] - tepbounds[0]) * rx).to_i
		    y1 = (dy + (tepbounds[3] - d[i * 2 + 3] + tepbounds[1]) * rx).to_i
		    draw_line(x0, y0, x1, y1)
		    x0 = x1
		    y0 = y1
		  }
	    }
	  }
	  bmp.save_to_file(fname)
	}
	on_export = lambda { |it|
	  basename = (mol.path ? File.basename(mol.path, ".*") : mol.name)
      fname = Dialog.save_panel("Export ORTEP file:", mol.dir, basename + ".eps",
	    "Encapsulated PostScript (*.eps)|*.eps|PNG (*.png)|*.png|TIFF (*.tif)|*.tif|ORTEP Instruction (*.tep)|*.tep|All files|*.*")
	  return if !fname
	  ext = File.extname(fname).downcase
	  if ext == ".eps"
	    on_export_eps.call(fname)
	  elsif ext == ".png" || ext == ".tif" || ext == ".tiff"
	    on_export_bitmap.call(fname)
	  elsif ext == ".tep"
	    filecopy("#{tmp}/TEP.IN", fname)
      end
	}
	on_document_modified = lambda { |m|
	}
	#  Close handler (called when the close box is pressed or the document is closed)
	@on_close = lambda { |*d|
	  cleanup_temp_dir(tmp)
	  tmp = nil
	  true
	}
	on_select_tab = lambda { |it|
	  tab = ["Atoms", "Bonds"][it[:value]]
	  # puts "tab = #{tab}"
	  table = item_with_tag("table")
	  table[:columns] = columns[tab]
	  table[:selection] = IntGroup[]
	  table[:refresh] = true
	}
	get_count = lambda { |it| descs[tab].count }
	get_value = lambda { |it, row, col| descs[tab][row][col] }
	has_popup_menu = lambda { |it, row, col|
	  if tab == "Atoms"
	    if col == 1
	      return atom_types
		elsif col == 2
		  return colors
		end
	  elsif tab == "Bonds"
		if col == 2
	      return bond_types
		elsif col == 3
		  return colors
		end
	  end
	  return nil
	}
	on_selection_changed = lambda { |it|
	  sel = it[:selection]
	  item_with_tag("remove")[:enabled] = (sel == nil || sel.count == 0 ? false : true)
	}
	is_item_editable = lambda { |it, row, col|
	  return has_popup_menu.call(it, row, col) == nil
	}
	popup_menu_selected = lambda { |it, row, col, sel|
	  titles = has_popup_menu.call(it, row, col)
	  return nil if titles == nil
	  descs[tab][row][col] = titles[sel]
	  it[:refresh] = true
	}
	set_value = lambda { |it, row, col, val|
	  descs[tab][row][col] = val
	  it[:refresh] = true	  
	}
	add_to_table = lambda { |it|
	  table = item_with_tag("table")
	  d = descs[tab][-1].dup
	  descs[tab].push(d)
	  table[:refresh] = true
	  table[:selection] = IntGroup[descs[tab].count - 1]
	  # puts descs[tab].inspect
	}
	remove_from_table = lambda { |it|
	  table = item_with_tag("table")
	  sel = table[:selection]
	  sel.reverse_each { |n|
	    descs[tab][n, 1] = []
	  }
	  table[:refresh] = true
	}
	layout(2,
	  layout(1,
	    item(:popup, :subitems=>["Atoms", "Bonds"], :action=>on_select_tab),
		item(:table, :width=>240, :height=>380, :flex=>[0,0,0,0,1,1], :tag=>"table",
		  :columns=>columns["Atoms"],
		  :on_count=>get_count,
		  :on_get_value=>get_value,
		  :on_set_value=>set_value,
		  :on_selection_changed=>on_selection_changed,
		  :is_item_editable=>is_item_editable,
		  :has_popup_menu=>has_popup_menu,
		  :on_popup_menu_selected=>popup_menu_selected),
		layout(2,
		  item(:button, :title=>"Add", :tag=>"add", :action=>add_to_table),
		  item(:button, :title=>"Remove", :tag=>"remove", :action=>remove_from_table, :enabled=>false),
		  :flex=>[0,1,0,0,0,0]),
	    :flex=>[0,0,0,0,0,1]),
	  layout(1,
	    item(:view, :width=>400, :height=>400, :tag=>"ortep", :on_paint=>on_draw_ortep, :flex=>[0,0,0,0,1,1]),
	    layout(2,
	      item(:button, :title=>"Refresh", :action=>on_update_ortep, :align=>:left),
		  item(:button, :title=>"Export as...", :action=>on_export, :align=>:right),
		  :flex=>[0,1,0,0,0,0]),
	    :flex=>[0,0,0,0,1,1]),
	  :flex=>[0,0,0,0,1,1]
	)
	set_min_size(480, 200)
	tepview = item_with_tag("ortep")
	listen(mol, "documentModified", on_document_modified)
	listen(mol, "documentWillClose", lambda { |m| close } )
	on_document_modified.call(nil)
    on_update_ortep.call(nil)
	show
  }
end

register_menu("Xtal\tDefine Unit Cell...", :cmd_define_unit_cell)
register_menu("Xtal\tShow Periodic Image...", :cmd_show_periodic_image,
  lambda { |m| m && m.cell != nil } )
register_menu("Xtal\tComplete by Symmetry", :complete_by_symmetry,
  lambda { |m| m && m.cell != nil } )
register_menu("Xtal\tCreate Packing Diagram...", :create_packing_diagram,
  lambda { |m| m && m.cell != nil } )
register_menu("Xtal\t-", nil)
register_menu("Xtal\tBest-fit Planes...", :cmd_plane)
register_menu("Xtal\tBonds and Angles with Sigma...", :cmd_bond_angle_with_sigma)
register_menu("Xtal\tShow ORTEP...", :cmd_show_ortep)

end
